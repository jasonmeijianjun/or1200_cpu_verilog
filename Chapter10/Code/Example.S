       .section .text,"ax"  
       .global _start
##############################           第7步            ##############################
      
        .org 0x000C               
      l.movhi r1,0x12             
      l.movhi r1,0x13             #在第6步中修改ITLB后，指令地址0x6010被翻译为0x0010                                 
      l.movhi r1,0x14             
      l.movhi r1,0x15                           
      l.ori r2,r0,0x8040          #r2=0x8040  
      l.movhi r1,0x9
      l.mtspr r0,r2,0x0011        #将0x8040写入SR，从而处理器处于用户模式
      l.movhi r1,0x16             #上一条指令执行的时候，本指令处于流水线的译码阶段不受影响
      l.movhi r1,0x17             #在设置处理器进入用户模式之前已经读取到本指令进入流水线，所以不受影响
      l.movhi r1,0x18             #读取指令时ITLBW0TR3的标志位uxe是0，所以本指令会引发指令页失效异常
      l.movhi r1,0x19             #上一条指令引发指令页失效异常，所以不会执行本条指令
      l.movhi r1,0x20             #不会执行本条指令

##############################           第1步            ##############################

      .org 0x100       
_start:
      l.andi r0,r0,0              #初始化r0-r4，都设置为0      
      l.extwz r1,r0
      l.extwz r2,r0
      l.extwz r3,r0
      l.extwz r4,r0

##############################           第2步            ##############################
######         初始化ITLB，初始化的方法就是使用l.mtspr写ITLBW0MRx、ITLBW0TRx   ####
                                  
      l.ori r3,r0,0x1             #设置寄存器r3为0x1 
      l.mtspr r0,r3,0x1200        #向地址0x1200的SPR写入0x1，0x1200对应的SPR就是ITLBW0MR0，
                                  #所以此处就是设置ITLBW0MR0，对应MR表的第0项放置0x1，
                                  #其中VPN为0，Valid为1

      l.ori r3,r0,0x20C0          #设置寄存器r3为0x20C0
      l.mtspr r0,r3,0x1280        #向地址0x1280的SPR写入0x20C0，0x1280对应的SPR就是ITLBW0TR0，
                                  #所以此处就是设置ITLBW0TR0，对应TR表的第0项放置0x20C0，其中PPN为0x1，
                                  #sxe为1，uxe为1，ci为0
                                  
                                  #上述两项设置使得有效地址0x0-0x01FFF被翻译为物理地址0x2000-0x3FFF
      
      l.ori r3,r0,0x0             #设置寄存器r3为0x0 
      l.mtspr r0,r3,0x1203        #向地址0x1203的SPR写入0x1，0x1203对应的SPR就是ITLBW0MR3，
                                  #所以此处就是设置ITLBW0MR3，对应MR表的第3项放置0x0，其中VPN为0，
                                  # Valid为0，也就是ILTBW0MR3无效

      l.ori r3,r0,0x40C0          #设置寄存器r3为0x40C0
      l.mtspr r0,r3,0x1283        #向地址0x1283的SPR写入0x40C0，0x1283对应的SPR就是ITLBW0TR3，
                                  #所以此处就是设置ITLBW0TR3，对应TR表的第3项放置0x40C0，其中PPN为0x2，
                                  # sxe为1，uxe为1，ci为0

                                  #上述两项设置使得有效地址0x6000-0x7FFF被翻译为物理地址0x4000-0x5FFF，但#是由于标志位V设置为0，所以使用该表项翻译时会出现ITLB失靶异常

##############################           第3步            ##############################

      l.mfspr r1,r0,0x0011        #读取SR到寄存器r1，r1初始化时的值为0x8001，可知SR[IME]为0表示IMMU禁用
      l.ori r1,r1,0x40            #修改r1为(0x8001 | 0x40)=0x8041
      
      l.ori r2,r2,0x0             #设置寄存器r2为0x0
      
      l.mtspr r0,r1,0x0011        #将0x8041写入SR，上述三条指令的作用是修改SR[IME]为1，从而使能IMMU，
                                  #但此时下面的一条指令已经被取出并进入流水线
      
      l.jr r2                     #在使能IMMU时，本指令已经被取出并进入流水线，会执行，该指令的作用是
                                  #跳转到有效地址0x0处，但是由于已经使能IMMU，所以跳转物理地址对应就是0x2000
      l.movhi r1,0x1              #延迟槽指令，使能IMMU的时候，本指令已经被取出并进入流水线，会执行
      l.movhi r1,0x2              #不会执行本条指令，因为IMMU已使能，所以会从0x2000处读取指令
##############################           第8步            ##############################
      
       .org 0x400                 #指令页失效处理例程
      l.movhi r1,0x15             #设置r1为0x15000
      l.movhi r1,0x16             #设置r1为0x16000，这两条指令的作用是验证处理器最终是否转移到指令页失效异
                                  #常例程
      l.nop 0x0001                #结束 

##############################           第5步            ##############################
      
         .org 0xA00               #ITLB失靶异常处理例程
      l.ori r3,r0,0x1             #设置寄存器r3为0x1 
      l.mtspr r0,r3,0x1203        #向地址0x1203的SPR写入0x1，0x1203对应的SPR就是ITLBW0MR3，
                                  #所以此处就是设置ITLBW0MR3，对应MR表的第3项放置0x1，
                                  #其中VPN为0，Valid为1

      l.ori r3,r0,0x4040          #设置寄存器r3为0x4040
      l.mtspr r0,r3,0x1283        #向地址0x1283的SPR写入0x4040，0x1283对应的SPR就是ITLBW0TR3，
                                  #所以此处就是设置ITLBW0TR3，对应TR表的第3项放置0x4040，其中PPN为0x2，
                                  # sxe为1，uxe为0，ci为0

                                  #上述两项设置使得有效地址0x6000-0x7FFF被翻译为物理地址0x4000-0x5FFF

      l.rfe                       #ITLB失靶异常返回，回到地址有效地址0x6000处，0x6000对应的物理地址是0x4000
     
##############################           第4步            ##############################

        .org 0x2000      
      l.movhi r1,0x3              #这几条指令没有特殊目的，只是表示处理器在此处执行过
      l.movhi r1,0x4
      l.movhi r1,0x5
      l.ori r2,r0,0x6000
      l.jr r2                     #跳转到有效地址0x6000处，该有效地址对应的就是ITLBW0MR3，
                                  #但是由于ITLBW0MR3的标志位V为0，也就是该ITLB表项无效，所以会引发ITLB
                                  #失靶异常，转移至ITLB失靶异常例程入口地址0xA00处执行
      l.movhi r1,0x6              #延迟槽指令会得到执行
      l.movhi r1,0x7              #不会执行本条指令
      l.movhi r1,0x8              #不会执行本条指令
##############################           第6步            ##############################
      
        .org 0x4000               #从失靶异常返回后，会转移到有效地址0x6000处，对应的物理地址就是0x4000
      l.ori r3,r0,0x0040          #设置寄存器r3为0x0040
      l.mtspr r0,r3,0x1283        #向地址0x1283的SPR写入0x0040，0x1283对应的SPR就是ITLBW0TR3，
                                  #所以此处就是设置ITLBW0TR3，对应TR表的第3项放置0x0040，其中PPN为0x0，
                                  # sxe为1，uxe为0，ci为0

                                  #上述两项设置使得有效地址0x6000-0x7FFF被翻译为物理地址0x0000-0x1FFFF

      l.movhi r1,0x9              #修改ITLB时本指令处于流水线取指阶段，会得到执行
      l.movhi r1,0x10             #修改ITLB时本指令处于流水线取指阶段，会得到执行

      l.movhi r1,0x11             #本指令不会得到执行，
                                  #本指令地址是0x4010，会重新翻译地址，#0x4010被翻译到0x0010                           

##############################           结  束            ##############################
